/*
	This file is part of solidity.

	solidity is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	solidity is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with solidity.  If not, see <http://www.gnu.org/licenses/>.
*/

syntax = "proto2";

import "abiV2Proto.proto";

message FunctionParamsAndReturns {
    repeated solidity.test.abiv2fuzzer.Type params = 1;
    repeated solidity.test.abiv2fuzzer.Type returns = 2;
}

message InterfaceFunction {
    enum StateMutability {
        PURE = 0;
        VIEW = 1;
        PAYABLE = 2;
    }
    required FunctionParamsAndReturns paramandret = 1;
    required StateMutability mut = 2;
    required bool override = 3;
}

message LibraryFunction {
    // Library functions cannot be payable
    enum StateMutability {
        PURE = 0;
        VIEW = 1;
    }
    enum Visibility {
        PUBLIC = 0;
        EXTERNAL = 1;
        INTERNAL = 2;
        PRIVATE = 3;
    }
    required FunctionParamsAndReturns paramandret = 1;
    required Visibility vis = 2;
    required StateMutability mut = 3;
    required Block b = 4;
    optional Modifier m = 5;
}

message ContractFunction {
    enum StateMutability {
        PURE = 0;
        VIEW = 1;
        PAYABLE = 2;
    }
    enum Visibility {
        PUBLIC = 0;
        EXTERNAL = 1;
        INTERNAL = 2;
        PRIVATE = 3;
    }
    required FunctionParamsAndReturns paramandret = 1;
    required Visibility vis = 2;
    required StateMutability mut = 3;
    required Block b = 4;
    optional Modifier m = 5;
    required bool implemented = 6;
    required bool virtualfunc = 7;
    required bool override = 8;
}

message Modifier {
    repeated solidity.test.abiv2fuzzer.Type params = 1;
    required Block b = 2;
}

/// Expressions
message Expression {
    oneof expr_oneof {
        Literal lit = 1;
        BinaryOp bop = 2;
        UnaryOp uop = 3;
        VarRef ref = 4;
    }
}

message VarRef {
    required int32 varnum = 1;
}

message Literal {
    oneof literal_oneof {
        bool blit = 1;
        string slit = 2;
    }
}

message BinaryOp {
    enum Operation {
        ADD = 1;
        SUB = 2;
        MUL = 3;
        DIV = 4;
    }
    required Operation op = 1;
    required Expression arg1 = 2;
    required Expression arg2 = 3;
}

message UnaryOp {
    enum Operation {
        INC = 1;
        DEC = 2;
    }
    required Operation op = 1;
    required Expression arg = 2;
}

/// Statements
message ElseStmt {
    required Block statements = 1;
}

message IfStmt {
    required Expression condition = 1;
    required Block statements = 2;
    optional ElseStmt else = 3;
}

message ForStmt {
    required Block pre = 1;
    required Expression condition = 2;
    required Block post = 3;
    required Block body = 4;
}

message CaseStmt {
    required Literal lit = 1;
    required Block block = 2;
}

message SwitchStmt {
    required Expression condition = 1;
    repeated CaseStmt cases = 2;
    optional Block default = 3;
}

message BreakStmt {}

message ContinueStmt {}

message ReturnStmt {
    required Expression value = 1;
}

message DoStmt {
    required Expression condition = 1;
    required Block statements = 2;
}

message WhileStmt {
    required Expression condition = 1;
    required Block statements = 2;
}

message Statement {
    oneof stmt_oneof {
        solidity.test.abiv2fuzzer.VarDecl var = 1;
        IfStmt ifstmt = 2;
        ForStmt forstmt = 3;
        SwitchStmt switchstmt = 4;
        BreakStmt breakstmt = 5;
        ContinueStmt continuestmt = 6;
        ReturnStmt returnstmt = 7;
        DoStmt dostmt = 8;
        WhileStmt whilestmt = 9;
    }
}

message Block {
    repeated Statement statements = 1;
}

message Library {
    repeated solidity.test.abiv2fuzzer.VarDecl state_vars = 1;
    repeated LibraryFunction funcdef = 2;
}

message Interface {
    repeated solidity.test.abiv2fuzzer.VarDecl state_vars = 1;
    repeated InterfaceFunction funcdef = 2;
    repeated Interface ancestors = 3;
}

message Contract {
    repeated solidity.test.abiv2fuzzer.VarDecl state_vars = 1;
    repeated ContractFunction funcdef = 2;
    required bool abstract = 3;
    repeated ContractOrInterface ancestors = 4;
}

message ContractOrInterface {
    oneof contract_or_interface_oneof {
        Contract c = 1;
        Interface i = 2;
    }
}

message ContractType {
    oneof contract_type_oneof {
        Contract c = 1;
        Library l = 2;
        Interface i = 3;
    }
}

message Program {
    repeated ContractType contracts = 1;
}

package solidity.test.solprotofuzzer;
